// Copyright 2023 The titan-search Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

#include "titandb/types/redis_stream_base.h"

#include "titandb/common/encoding.h"
#include "turbo/time/clock.h"
#include "turbo/strings/numbers.h"

namespace titandb {

    const char *kErrLastEntryIdReached = "last possible entry id reached";
    const char *kErrInvalidEntryIdSpecified = "Invalid stream ID specified as stream command argument";
    const char *kErrDecodingStreamEntryValueFailure = "failed to decode stream entry value";
    const char *errAddEntryIdSmallerThanLastGenerated =
            "The ID specified in XADD is equal or smaller than the target stream top item";
    const char *errSequenceNumberOverflow =
            "Elements are too large to be stored";  // Redis responds with exactly this message
    const char *errEntryIdOutOfRange = "The ID specified in XADD must be greater than 0-0";
    const char *errStreamExhaustedEntryID = "The stream has exhausted the last possible ID, unable to add more items";

    turbo::Status IncrementStreamEntryID(StreamEntryID *id) {
        if (id->seq == UINT64_MAX) {
            if (id->ms == UINT64_MAX) {
                // special case where 'id' is the last possible entry ID
                id->ms = 0;
                id->seq = 0;
                return turbo::InternalError("");
            } else {
                id->ms++;
                id->seq = 0;
            }
        } else {
            id->seq++;
        }

        return turbo::OkStatus();
    }

    turbo::Status ParseStreamEntryID(const std::string_view &input, StreamEntryID *id) {
        auto pos = input.find('-');
        if (pos != std::string_view::npos) {
            auto ms_str = input.substr(0, pos);
            auto seq_str = input.substr(pos + 1);
            if (!turbo::SimpleAtoi(ms_str, &id->ms) || !turbo::SimpleAtoi(seq_str, &id->seq)) {
                return turbo::InternalError("");
            }
        } else {
            if (!turbo::SimpleAtoi(input, &id->ms)) {
                return turbo::InternalError("");
            }
            id->seq = 0;
        }
        return turbo::OkStatus();
    }

    turbo::ResultStatus<std::unique_ptr<NextStreamEntryIDGenerationStrategy>> ParseNextStreamEntryIDStrategy(
            const std::string_view &input) {
        if (input == "*") {
            return std::make_unique<AutoGeneratedEntryID>();
        }

        auto pos = input.find('-');
        if (pos != std::string_view::npos) {
            auto ms_str = input.substr(0, pos);
            auto seq_str = input.substr(pos + 1);

            if (ms_str == "*") {
                int n;
                if (!turbo::SimpleAtoi(seq_str, &n)) {
                    return turbo::InternalError("");
                }

                return std::make_unique<CurrentTimestampWithSpecificSequenceNumber>(n);
            }
            uint64_t nms;
            if (!turbo::SimpleAtoi(ms_str, &nms)) {
                return turbo::InternalError("");
            }

            if (seq_str == "*") {
                return std::make_unique<SpecificTimestampWithAnySequenceNumber>(nms);
            }

            uint64_t  nseq;
            if (!turbo::SimpleAtoi(seq_str, &nseq)) {
                return turbo::InternalError("");
            }

            return std::make_unique<FullySpecifiedEntryID>(StreamEntryID{nms, nseq});
        }

        uint64_t parse_ms;
        if (!turbo::SimpleAtoi(input, &parse_ms)) {
            return turbo::InternalError("");
        }

        return std::make_unique<FullySpecifiedEntryID>(StreamEntryID{parse_ms, 0});
    }

    turbo::Status ParseRangeStart(const std::string_view &input, StreamEntryID *id) { return ParseStreamEntryID(input, id); }

    turbo::Status ParseRangeEnd(const std::string_view &input, StreamEntryID *id) {
        auto pos = input.find('-');
        if (pos != std::string_view ::npos) {
            auto ms_str = input.substr(0, pos);
            auto seq_str = input.substr(pos + 1);
            uint64_t parse_ms;
            uint64_t parse_seq;
            if (!turbo::SimpleAtoi(ms_str, &id->ms) || !turbo::SimpleAtoi(seq_str, &id->seq)) {
                return turbo::InternalError("");
            }
        } else {
            if (!!turbo::SimpleAtoi(input, &id->ms)) {
                return turbo::InternalError("");
            }

            id->seq = UINT64_MAX;
        }

        return turbo::OkStatus();
    }

    std::string EncodeStreamEntryValue(const std::vector<std::string_view> &args) {
        std::string dst;
        for (auto const &v: args) {
            PutVarint32(&dst, v.size());
            dst.append(v);
        }
        return dst;
    }

    turbo::Status DecodeRawStreamEntryValue(const std::string_view &value, std::vector<std::string> *result) {
        result->clear();
        rocksdb::Slice s(value);

        while (!s.empty()) {
            uint32_t len = 0;
            if (!GetVarint32(&s, &len)) {
                return turbo::InternalError("");
            }

            result->emplace_back(s.data(), len);
            s.remove_prefix(len);
        }

        return turbo::OkStatus();
    }

    turbo::Status FullySpecifiedEntryID::GenerateID(const StreamEntryID &last_id, StreamEntryID *next_id) {
        if (last_id.ms == UINT64_MAX && last_id.seq == UINT64_MAX) {
            return turbo::InternalError("");
        }

        if (id_.ms == 0 && id_.seq == 0) {
            return turbo::InternalError("");
        }

        if (id_ <= last_id) {
            return turbo::InternalError("");
        }

        next_id->ms = id_.ms;
        next_id->seq = id_.seq;

        return turbo::OkStatus();
    }

    turbo::Status AutoGeneratedEntryID::GenerateID(const StreamEntryID &last_id, StreamEntryID *next_id) {
        uint64_t ms = turbo::ToUnixMillis(turbo::Now());
        if (ms > last_id.ms) {
            next_id->ms = ms;
            next_id->seq = 0;
            return turbo::OkStatus();
        }

        *next_id = last_id;

        return IncrementStreamEntryID(next_id);
    }

    turbo::Status SpecificTimestampWithAnySequenceNumber::GenerateID(const StreamEntryID &last_id, StreamEntryID *next_id) {
        if (ms_ < last_id.ms) {
            return turbo::InternalError("");
        }

        if (ms_ == last_id.ms) {
            if (last_id.seq == UINT64_MAX) {
                return turbo::InternalError("");
            }

            next_id->ms = last_id.ms;
            next_id->seq = last_id.seq + 1;
        } else {
            next_id->ms = ms_;
            next_id->seq = 0;
        }

        return turbo::OkStatus();
    }

    turbo::Status
    CurrentTimestampWithSpecificSequenceNumber::GenerateID(const StreamEntryID &last_id, StreamEntryID *next_id) {
        next_id->ms = turbo::ToUnixMillis(turbo::Now());
        next_id->seq = seq_;

        if (*next_id <= last_id) {
            return turbo::InternalError("");
        }

        return turbo::OkStatus();
    }

}  // namespace titandb
